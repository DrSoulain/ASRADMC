# -*- coding: utf-8 -*-
"""
Created on Wed Apr 24 11:31:43 2019

@author: Anthony Soulain (University of Sydney)

------------------------------------------------------------------------
asradmc: Tools to perform RT modeling on analytical grid or ramses data
------------------------------------------------------------------------

Function used with RAMSES simulations. 

Core functions are: 

`amr_to_cube()`:
    read/save RAMSES simulation and convert it to regular 3d grid,
`ramses_gas_to_dust()`:
    Convert the 3d gas grid generated by RAMSES (with amr_to_cube())
    to the 3d dust grid used with radmc3d.

------------------------------------------------------------------------
"""

import os
import time

import h5py
import numpy as np
import pymses
from astools.all import AllMyFields
from astropy import constants as const
from matplotlib import pyplot as plt
from matplotlib.colors import LogNorm
from pymses import RamsesOutput
from pymses.sources.ramses.output import Scalar, Vector
from pymses.utils import constants as C

# Unit for RADMC3D (cgs)
# ----------------------
pc = const.pc.cgs.value  # Parsec                  [cm]
ms = const.M_sun.cgs.value  # Solar mass          [g]
au = const.au.cgs.value  # Astronomical Unit       [cm]

RamsesOutput.amr_field_descrs_by_file = {"3D": {"hydro": [Scalar("rho", 0),
                                                          Vector("vel", [1, 2, 3]), Scalar(
                                                              "P", 4), Scalar("OB", 5),
                                                          Scalar("WR", 6)],
                                                "grav": [Vector("g", [0, 1, 2]), Scalar("T", 10)]
                                                }
                                         }  # Field of the simulation (not standard)


def _save_ramses_hdf5(ramses_model, savedir=''):
    """ Save RAMSES model as hdf5 file from dictionnary format
    (see AmrToCube()). """
    start_time = time.time()
    ioutput = ramses_model['info']['ioutput']
    npts = ramses_model['info']['npts']

    filerho = savedir + '/rho%i_npts%i.hdf5' % (ioutput, npts)
    filemix = savedir + '/mix%i_npts%i.hdf5' % (ioutput, npts)
    fileinfo = savedir + '/info%i_npts%i.hdf5' % (ioutput, npts)
    fileWR = savedir + '/WRcomp%i_npts%i.hdf5' % (ioutput, npts)
    fileOB = savedir + '/OBcomp%i_npts%i.hdf5' % (ioutput, npts)

    with h5py.File(filerho, 'w') as hf:
        hf.create_dataset("rho", data=ramses_model['rho'])
    with h5py.File(filemix, 'w') as hf:
        hf.create_dataset("mix", data=ramses_model['mix'])
    with h5py.File(fileWR, 'w') as hf:
        hf.create_dataset("WR", data=ramses_model['WR'])
    with h5py.File(fileOB, 'w') as hf:
        hf.create_dataset("OB", data=ramses_model['OB'])
    with h5py.File(fileinfo, 'w') as hf:
        for k, v in ramses_model['info'].items():
            hf.create_dataset(k, data=v)

    t = time.time() - start_time
    print('### output %i, npts %i : time to write hdf5 files %2.2f s' %
          (ioutput, npts, t))
    return None


def _read_ramses_hdf5(ioutput, npts, savedir=''):
    """ Read RAMSES model from saved hdf5 file. """
    filerho = savedir + '/rho%i_npts%i.hdf5' % (ioutput, npts)
    filemix = savedir + '/mix%i_npts%i.hdf5' % (ioutput, npts)
    fileinfo = savedir + '/info%i_npts%i.hdf5' % (ioutput, npts)
    fileWR = savedir + '/WRcomp%i_npts%i.hdf5' % (ioutput, npts)
    fileOB = savedir + '/OBcomp%i_npts%i.hdf5' % (ioutput, npts)

    hf = h5py.File(filerho, 'r')
    rho = hf['rho'][:]
    hf.close()

    hf = h5py.File(filemix, 'r')
    mix = hf['mix'][:]
    hf.close()
    try:
        hf = h5py.File(fileWR, 'r')
        wr = hf['WR'][:]
        hf.close()
        hf = h5py.File(fileOB, 'r')
        ob = hf['OB'][:]
        hf.close()
    except IOError:
        pass

    hf = h5py.File(fileinfo, 'r')
    info = {}
    for item in list(hf.iterkeys()):
        info[item] = hf[item][()]
    hf.close()

    ramses_model = {'rho': rho, 'mix': mix, 'info': info}
    try:
        ramses_model['WR'] = wr
        ramses_model['OB'] = ob
    except UnboundLocalError:
        pass
    return ramses_model


def _convert_unit_visu(ramses_model, x_WR, y_WR, rot=True, mas=True):
    """ Convert unit format to visualise RAMSES simulations. """
    npts = ramses_model['info']['npts']
    sep = ramses_model['info']['sep']
    theta = ramses_model['info']['bin_phase']
    fov = ramses_model['info']['fov']
    pix_size = float(fov) / npts

    if mas:
        extent = (np.array([-y_WR, npts - y_WR, npts - x_WR, -x_WR]) -
                  0.5) * pix_size
        if rot:
            x_OB = sep * np.sin(np.deg2rad(-theta + 90))
            y_OB = sep * np.cos(np.deg2rad(-theta + 90))
        else:
            x_OB = sep * np.sin(np.deg2rad(-theta))
            y_OB = sep * np.cos(np.deg2rad(-theta))
    else:
        if rot:
            x_OB = sep * np.cos(np.deg2rad(-theta - 90))
            y_OB = sep * np.sin(np.deg2rad(-theta - 90))
        else:
            x_OB = sep * np.cos(np.deg2rad(-theta))
            y_OB = sep * np.sin(np.deg2rad(-theta))
        extent = [-0.5, npts - 0.5, npts - 0.5, -0.5]
    return x_OB, y_OB, extent


def _apply_gas2dust_ratio(rho_gas, xi):
    """ Apply gas to dust ratio to compute the 3d dusty grid. 

    `rho_gas` {array}:
        3d gas grid from RAMSES,\n
    `xi` {float}:
        gas to dust ratio [%].

    Output:
    -------
    `rho_dust` {array}:
        3d dusty grid for radmc3d.
    """
    rho_dust = rho_gas.copy() * xi
    return rho_dust


def _apply_mixing_threshold(rho_dust, mix_grid, mix):
    """ Apply mixing threshold to the dusty grid: used to impose
    the dust nucleation where hydrogen enrichement is sufficient. 

    `rho_dust` {array}:
        3d dusty grid,\n
    `mix_grid` {array}:
        3d mixing grid from ramses,\n
    `mix` {float}:
        Minimum hydrogen enrichment from the OB star [%].

    Output:
    -------
    `rho_dust` {array}:
        3d dusty grid for radmc3d.
    """
    m1 = mix
    m2 = 1 - m1
    rho_dust[(mix_grid <= m1 * m2)] = 1e-50
    return rho_dust


def _apply_sublimation_threshold(rho_dust_thr, rnuc, ramses_model):
    """ Remove dust in the grid between the stellar source and rnuc. 

    Parameters:
    -----------

    `rho_dust_thr` {array}:
        Final dusty grid for radmc3d,\n
    `rnuc` {float}:
        Nucleation radius [mas],\n
    `ramses_model` {dict}:
        RAMSES model (see amr_to_cube()).

    Output:
    -------
    `rho_dust_thr` {array}:
        3d dusty grid for radmc3d.
    """
    # Open parameters
    rho_gas = ramses_model['rho']
    fov = ramses_model['info']['fov'] / 1000.
    npts = rho_gas.shape[0]

    # Compute 3d map
    x_centred = np.linspace(0, npts, npts) - ramses_model['info']['p_WR'][0]
    y_centred = np.linspace(0, npts, npts) - ramses_model['info']['p_WR'][1]
    z_centred = np.linspace(0, npts, npts) - npts / 2

    xx, yy, zz = np.meshgrid(x_centred, y_centred, z_centred,
                             indexing='ij', sparse=False,
                             copy=True)

    rr = np.sqrt(xx**2 + yy**2 + zz**2)  # Distance map 3D
    rr_mas = (rr / (npts / 2.)) * (fov / 2.)

    # Apply sublimation/nucleation threshold (remove between star and rnuc).
    rho_dust_thr[rr_mas < rnuc] = 1e-50
    return rho_dust_thr, rr_mas


def _compute_total_mass_grid(rho_dust, fov, dpc):
    """ Compute total mass [solar mass] in the grid. """
    sizex = fov * dpc * au
    npts = rho_dust.shape[0]
    m_dust = np.sum(rho_dust * ((sizex / npts)**3) / ms)
    return m_dust


def _visu_slice_radmc_input(rho_dust, stellar_pos, rr_mas, fov, dpc, unit='AU',
                            display=True):
    """ Plot the middle plan image from the 3d dusty grid (input for ramdc3d). """
    npts = rho_dust.shape[2]
    i_t = npts / 2

    im_thres = rho_dust[:, :, i_t]

    vmin, vmax = rho_dust.max() / 1e3, rho_dust.max()

    dic_conv = {'mas': 1000.,
                'AU': dpc,
                'cm': dpc * au,
                'pix': 1}

    extent = np.array([-fov / 2., fov / 2, -fov / 2, fov / 2]) * dic_conv[unit]
    pix_size = (2 * abs(extent[0])) / npts

    x_wr, y_wr = stellar_pos[0] * pix_size, stellar_pos[1] * pix_size
    x_ob, y_ob = stellar_pos[2] * pix_size, stellar_pos[3] * pix_size

    pstar1 = [x_wr, y_wr]
    pstar2 = [x_ob, y_ob]

    im_dist = np.rot90(rr_mas[:, :, i_t]) * dpc

    if display:
        plt.figure(figsize=(9, 7))
        plt.plot(x_ob, y_ob, 'c*', ms=12)
        plt.plot(x_wr, y_wr, 'w*', ms=12)
        plt.imshow(np.rot90(im_thres), norm=LogNorm(), vmin=vmin, vmax=vmax,
                   extent=extent, cmap='gist_earth')
        cb = plt.colorbar()
        plt.contour(np.flipud(im_dist), extent=extent, origin='lower',
                    levels=np.array([10, 12.5, 14.5]) * 2.58, linewidths=5,
                    alpha=.7, colors=["#4698cb", "#3fc1c9", "#364f6b"])
        cb.set_label(r'$\rho_{dust}$ [g/cm$^2$]', fontsize=18)
        plt.xlabel('X [%s]' % unit, fontsize=18)
        plt.ylabel('Y [%s]' % unit, fontsize=18)
        plt.tight_layout()
        plt.show(block=False)
    return pstar1, pstar2


def amr_to_cube(ioutput, npts, dirmodel, dpc=2600, dbin=2.34,
                step_output=0.00125, rewrite=False, verbose=True):
    """
    Transform AMR RAMSES data to regular grid cube.

    Parameters
    ----------

    `ioutput` {int}:
        number of the RAMSES output,\n
    `npts` {int}:
        size of the cube used for the interpolation,\n
    `dirmodel` {str}:
        RAMSES models directory,\n
    `dpc` {float}:
        distance of the system in parsec,\n
    `dbin` {float}:
        binary separation [AU],\n
    `step_output` {float}:
        step of the RAMSES simulation (in orbital phase),\n
    `dir` {str}:
        path to the RAMSES directory containing output,\n
    `rewrite` {bool}:
        re-write the saved dpy file containing the cube if already exist.


    Returns
    -------

    `ramses_model` {dict}:
        Dictionary containing the interpolated cube from RAMSES output. Keys are `rho` for density map,
        `mix` for mixing map, `WR` and `OB`, `info` is another dict with usefull informations 
        (npts, fov and star positions).
    """
    savecube_dir = dirmodel + 'Save_dpy_RAMSES'

    if (not os.path.exists(dirmodel + 'Save_dpy_RAMSES')):
        os.system('mkdir %s' % (savecube_dir))

    name_simu_dir = "%s/simu%i" % (savecube_dir, ioutput)

    if (not os.path.exists(name_simu_dir)):
        os.system('mkdir %s' % (name_simu_dir))

    unit = 1e-8 * (C.Msun / (dbin * C.au)**3)

    # name_file = name_simu_dir + "/simu%s_npts%s.dpy"%(ioutput, npts)

    name_file = name_simu_dir + "/rho%i_npts%i.hdf5" % (ioutput, npts)

    # The simulation size box scale
    # -----------------------------

    sep = dbin / (dpc / 1000.)  # Binary separation [mas] (conversion 2.34 au)

    ro = pymses.RamsesOutput(dirmodel, ioutput)

    fov_unit = ro.info[
        'boxlen']  # Unit size of the simulation : binary separation
    fov = fov_unit * sep

    # print(ro.info.keys())
    if verbose:
        print('\n----------------')
        print(("Simulation #%s\n" % ioutput))
        print('ndim = %i' % ro.info['ngridmax']**(1 / 3.))
        print(('* Box size : %2.2f sep; %2.2f mas' % (fov_unit, fov)))
    if ro.info['levelmax'] == ro.info['levelmin']:
        if verbose:
            print('* No AMR')
    else:
        if verbose:
            print(('* AMR used with %i levels' %
                   (ro.info['levelmax'] - ro.info['levelmin'])))

    if (not os.path.exists(name_file)) or rewrite:
        ro = pymses.RamsesOutput(dirmodel, ioutput)

        # The simulation size box scale
        # -----------------------------

        sep = dbin / (dpc / 1000.
                      )  # Binary separation [mas] (conversion 2.34 au)

        fov_unit = ro.info[
            'boxlen']  # Unit size of the simulation : binary separation
        fov = fov_unit * sep

        if verbose:
            print('\n----------------')
            print(("Simulation #%s\n" % ioutput))
            print(('* Box size : %2.2f sep; %2.2f mas' % (fov_unit, fov)))
        if ro.info['levelmax'] == ro.info['levelmin']:
            if verbose:
                print('* No AMR')
        else:
            if verbose:
                print(('* AMR used with %i levels' %
                       (ro.info['levelmax'] - ro.info['levelmin'])))

        #  Simple visualisation
        # -----------------------------
        if verbose:
            print(('* Chosen # pixels = %i' % npts))

        x, y, z = np.mgrid[0:1:complex(0, npts + 1), 0:1:complex(0, npts + 1),
                           0:1:complex(0, npts + 1)]

        # Reshape
        npoints = np.prod(x.shape)
        x1 = np.reshape(x, npoints)
        y1 = np.reshape(y, npoints)
        z1 = np.reshape(z, npoints)

        # Modify for Pymses
        pxyz = np.array([x1, y1, z1])
        pxyz = pxyz.transpose()
        output = pymses.RamsesOutput(dirmodel, ioutput)
        source = output.amr_source(["rho", "WR", "OB"])

        # Sample Hydro Fields
        dset = pymses.analysis.sample_points(source, pxyz, use_C_code=False,
                                             verbose=False)

        cube_density = np.reshape(dset["rho"], (npts + 1, npts + 1, npts + 1))
        cube_density_cgs = cube_density * unit.val

        cube_WR = np.reshape(dset["WR"], (npts + 1, npts + 1, npts + 1))
        cube_OB = np.reshape(dset["OB"], (npts + 1, npts + 1, npts + 1))

        cube_density = cube_density[:-1, :-1, :-1]
        cube_density_cgs = cube_density_cgs[:-1, :-1, :-1]
        cube_WR = cube_WR[:-1, :-1, :-1]
        cube_OB = cube_OB[:-1, :-1, :-1]
        cube_mixing = cube_WR * cube_OB

        im_dens = cube_density_cgs[:, :, npts / 2]

        dens_max = im_dens.max()

        sc_WR = np.where(im_dens == dens_max)
        x_WR, y_WR = sc_WR[0][0], sc_WR[1][0]

        bin_phase = 360 * (
            ioutput * step_output
        )  # orientation of the binary (from horizontal east ->)

        x_OB = sep * np.sin(np.deg2rad(-bin_phase))
        y_OB = sep * np.cos(np.deg2rad(-bin_phase))

        pix_size = float(fov) / npts

        x_OB_pix = x_WR + (x_OB / pix_size)
        y_OB_pix = y_WR + (y_OB / pix_size)

        if verbose:
            print('\n####### Binary position ######')
            print(
                ("WR star at X = %2.2f, Y = %2.2f pix" % (x_WR + 0.5, y_WR + 0.5)))
            print(("OB star at X = %2.2f, Y = %2.2f pix" % (x_OB_pix, y_OB_pix)))

        ramses_model = {}

        ramses_model['info'] = {"ioutput": ioutput,
                                "npts": npts,
                                "fov": fov,
                                "sep": sep,
                                "bin_phase": bin_phase,
                                "p_WR": [x_WR + 0.5, y_WR + 0.5],
                                "p_OB": [x_OB_pix, y_OB_pix],
                                'levelmax': ro.info['levelmax'],
                                'levelmin': ro.info['levelmin']
                                }

        ramses_model['rho'] = cube_density_cgs
        ramses_model['mix'] = cube_mixing
        ramses_model['WR'] = cube_WR
        ramses_model['OB'] = cube_OB

        _save_ramses_hdf5(ramses_model, savedir=name_simu_dir)

        if verbose:
            print("\n####################")
            print(("rho%s_npts%s.hdf5" % (ioutput, npts) + " file saved"))
            print("####################")
    else:
        if verbose:
            print("%s file already exists." % ("simu%s_npts%s.hdf5" %
                                               (ioutput, npts)))

        ramses_model = _read_ramses_hdf5(ioutput, npts, savedir=name_simu_dir)

    return ramses_model


def ramses_gas_to_dust(ramses_model, param, unit='AU', verbose=False,
                       display=False):
    """ Convert 2D gas grid generated by RAMSES to the dust grid using
    sublimation, mixing and gas to dust ratio.

    Parameters:
    -----------

    `ramses_model` {dict}:
        Dictionary containing the interpolated cube from RAMSES output (see
        amr_to_cube() for details),\n
    `param` {dict}:
        Parameters for the RT process with radmc3d,\n
    `unit` {str}:
        Unit for the visualisation function (default: 'AU' ('mas', 'cm', 'pix')).

    Outputs:
    --------

    `rho_dust` {array}:
        3d grid used for the RT with radmc3d,\n
    `gridinfo` {class}:
        Class like with information about the ramses input,
        stellar position, grid, etc. (see details with gridinfo.__dict__.keys()),\n
    `m_dust` {float}:
        Total computed mass of dust in the grid.


    """
    # Open gas grid
    mix_grid = ramses_model['mix']
    rho_gas = ramses_model['rho']
    npts = rho_gas.shape[0]

    # Open radmc simulation parameters
    xi, rnuc, dpc, mix = param['xi'], param['rnuc'], param['dpc'], param['mix']

    # Open RAMSES informations
    x_wr = ramses_model['info']['p_WR'][0] - npts / 2.
    y_wr = ramses_model['info']['p_WR'][1] - npts / 2.

    sep = ramses_model['info']['sep']
    bin_phase = ramses_model['info']['bin_phase']
    fov = ramses_model['info']['fov'] / 1000.

    ra_OB = sep * np.cos(np.deg2rad(bin_phase))
    dec_OB = sep * np.sin(np.deg2rad(bin_phase))

    x_ob = x_wr + ra_OB / ((fov * 1000.) / npts) + 1
    y_ob = y_wr - dec_OB / ((fov * 1000.) / npts)

    stellar_pos = [x_wr, y_wr, x_ob, y_ob]
    if verbose:
        print("m1 = %2.2f; m2 = %2.2f" % (mix * 100, (1 - mix) * 100))

    # Step 1: convert gas to dust applying gas to dust ratio xi.
    rho_dust = _apply_gas2dust_ratio(rho_gas, xi)

    # Step 2: apply mixing threshold
    rho_dust = _apply_mixing_threshold(rho_dust, mix_grid, mix)

    # Step 3: apply sublimation threshold
    rho_dust, rr_mas = _apply_sublimation_threshold(
        rho_dust, rnuc, ramses_model)

    m_dust = _compute_total_mass_grid(rho_dust, fov, dpc)

    if verbose:
        print(('Computed total mass Mdust = %2.2e Msun\n' % m_dust))

    pstar1, pstar2 = _visu_slice_radmc_input(rho_dust, stellar_pos, rr_mas, fov, dpc,
                                             unit=unit, display=display)

    sizex = fov * dpc * au
    sizey, sizez = sizex, sizex
    nx = ny = nz = npts

    xi = np.linspace(-sizex / 2., sizex / 2., nx + 1)
    yi = np.linspace(-sizey / 2., sizey / 2., ny + 1)
    zi = np.linspace(-sizez / 2., sizez / 2., nz + 1)

    gridinfo = AllMyFields({'nx': npts, 'ny': npts, 'nz': npts,
                            'xi': xi, 'yi': yi, 'zi': zi,
                            'pstar1': pstar1, 'pstar2': pstar2,
                            'gaz_grid': rho_gas,
                            'mix': mix
                            })

    return rho_dust, gridinfo, m_dust


def visu_cube_ramses(ramses_model, rot=True, mas=True):
    """
    Visualisation tool of the RAMSES cube generated by AmrToCube function.

    Parameters
    ----------
    `ramses_model` {dict}:
        Output of amr_to_cube() function,\n
    `rot` {bool}:
        If True, rotate the image by 90 deg for a more convenient display,\n
    `mas` {bool}:
        if True, extent of the image is in mas, False is in pixels.
    """
    npts = ramses_model['info']['npts']
    fov = ramses_model['info']['fov']
    pix_size = float(fov) / npts
    dens = ramses_model['rho']
    mix = ramses_model['mix']

    if rot:
        ii = npts / 2
        im_dens = np.rot90(dens[:, :, ii])
        im_mix = np.rot90(mix[:, :, ii])
    else:
        im_dens = dens[:, :, npts / 2]
        im_mix = mix[:, :, npts / 2]

    dens_max = im_dens.max()
    dens_min = im_dens.min()

    sc_WR = np.where(im_dens == dens_max)
    x_WR, y_WR = sc_WR[0][0], sc_WR[1][0]

    x_OB, y_OB, extent = _convert_unit_visu(ramses_model, x_WR, y_WR,
                                            rot=rot, mas=mas)

    x_OB_pix = x_WR - (x_OB / pix_size)
    y_OB_pix = y_WR - (y_OB / pix_size)

    fontsize = 14
    fig = plt.figure(figsize=(10, 4))
    plt.subplot(1, 2, 1)
    plt.title('Gaz density', fontweight='bold', color='grey',
              fontsize=fontsize)
    if mas:
        plt.plot(x_OB, y_OB, "g+", ms=8, label='OB star')
        plt.plot(0, 0, "r+", ms=8, label='WR star')
        plt.ylabel("Y [mas]")
        plt.xlabel("X [mas]")
    else:
        plt.plot(x_OB_pix, y_OB_pix, "g+", ms=8, label='OB star')
        plt.plot(x_WR, y_WR, "r+", ms=8, label='WR star')
        plt.ylabel("Y [pix]")
        plt.xlabel("X [pix]")

    plt.imshow(im_dens, norm=LogNorm(), vmin=dens_min, vmax=dens_max,
               origin='upper', extent=extent)
    cb = plt.colorbar()
    cb.set_label(r'$\rho$ [g/cm$^3$]')
    plt.subplot(1, 2, 2)
    plt.title('Mixing', fontweight='bold', color='grey', fontsize=fontsize)
    if mas:
        plt.plot(x_OB, y_OB, "g+", ms=8, label='OB star')
        plt.plot(0, 0, "r+", ms=8, label='WR star')
        plt.xlabel("X [mas]")
    else:
        plt.plot(y_OB_pix, x_OB_pix, "g+", ms=8, label='OB star')
        plt.plot(y_WR + 0.5, x_WR + 0.5, "r+", ms=8, label='WR star')
        plt.xlabel("X [pix]")

    plt.imshow(im_mix, cmap='gist_stern', origin='upper',
               extent=extent)
    cb2 = plt.colorbar()
    cb2.set_label(r'$\chi_{WR}\chi_{OB}$')
    plt.tight_layout()
    plt.show(block=False)
    return fig
